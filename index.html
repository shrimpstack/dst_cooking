<!DOCTYPE html>
<html>
  <head>
    <title>烹飪鍋模擬器</title>
    <meta charset="utf-8">
    <script src="./universal.js"></script>
    <script src="./食材.js"></script>
    <script src="./食譜.js"></script>
    <link rel="stylesheet" href="./css.css"/>
  </head>
  <body>
    <div id="鍋子">
      <div id="鍋子格區"></div>
      <label><input id="是沃利" type="checkbox" oninput="更新結果(); 顯示全食譜();"/>沃利</label>
    </div>
    <div id="結果"></div>
    <div id="食材類型"></div>
    <div id="食材"></div>
    <div id="推薦做法" class="hidden"></div>
    <div id="食譜">
      <select id="食譜排列" onchange="顯示全食譜()">
        <option value="FL">FL排列</option>
        <option value="HP">HP排列</option>
        <option value="SAN">SAN排列</option>
      </select>
      <div id="食譜列"></div>
    </div>
    <script>
      const 鍋子格 = [];
      window.addEventListener("load", () => {
        for(let f=0; f<4; f++) 鍋子格[f] = 生成鍋子格();
        處理食譜();
        顯示全食譜();
        顯示食材();
        開始推薦做法();
      });
      function 生成格(type = "食材") {
        let 格 = new_el("sq");
        Object.defineProperty(格, "name", {
          get: () => 格.getAttribute("name"),
          set: (new_name) => {
            if(!new_name) {
              格.removeAttribute("name");
              格.removeAttribute("style");
            }
            else {
              格.setAttribute("name", new_name);
              格.style.setProperty("--img", `url(./imgs/${type}/${new_name}.png)`);
            }
          },
        });
        return 格;
      }
      function 生成鍋子格() {
        let 格 = 生成格();
        鍋子格區.append(格);
        格.addEventListener("click", () => 取下食材(格));
        return 格;
      }
      function 取下食材(el) {
        el.name = null;
        更新結果();
      }
      function 顯示食材分類() {
        let 類型 = ["全部", "肉", "魚", "水果", "蔬菜", "配料", "其他", "飽食度推薦", "補血推薦", "理智推薦"];
        let 按鈕列 = 類型.map(類型名稱 => {
          let btn = new_el_to_el(食材類型, "button", 類型名稱);
          btn.addEventListener("click", () => {
            按鈕列.forEach(el => el.classList.remove("active"));
            btn.classList.add("active");
            if(/推薦$/.test(類型名稱)) 依照分類切換推薦顯示(類型名稱);
            else 依照分類切換食材顯示(類型名稱);
          });
          return btn;
        });
        按鈕列[0].click();
      }
      const 推薦做法表 = [
        {類型: "飽食度推薦", 料理: "肉丸", 食材: ["1", "怪獸肉", "小肉", "蛙腿", "3", "蝴蝶翅膀"],
          說明: "【飽食度62】任意肉+三個蝴蝶翅膀，開始可以刷蝴蝶時很好用，怪物肉也能用"},
        {類型: "飽食度推薦", 料理: "肉丸", 食材: ["4", "蛙腿"],
          說明: "【飽食度62】下青蛙雨的時候會有超多蛙腿，盡量用"},
        {類型: "飽食度推薦", 料理: "培根煎蛋", 食材: ["1", "怪獸肉", "1", "小肉", "小魚塊", "2", "鳥蛋"],
          說明: "【飽食度75】會順便補血20，怪物肉開始超多時可以做，怪物肉拿去餵鳥籠的鳥換成蛋，加上一個任意肉或魚"},
        {類型: "飽食度推薦", 料理: "普通煎蛋", 食材: ["1", "怪獸肉", "3", "鳥蛋"],
          說明: "【飽食度50】怪物肉開始超多時可以做，沒有肉或魚的替代方案"},
        {類型: "飽食度推薦", 料理: "火雞正餐", 食材: ["2", "鳥腿", "1", "怪獸肉", "小肉", "小魚塊", "1", "莓果", "採摘的紅菇"],
          說明: "【飽食度75】會順便補血20，有殺到火雞就用兩個鳥腿做這個，加一個任意肉或魚，怪物肉也可，再加一個任意漿果或任意蘑菇"},

        {類型: "補血推薦", 料理: "魚肉玉米捲", 食材: ["1", "小魚塊", "1", "玉米", "2", "採摘的紅菇", "莓果", "蝴蝶翅膀", "必忘我", "NO", "樹枝"],
          說明: "【補血20】任意魚+一個玉米，填充物不要樹枝就不會變成炸魚排"},
        {類型: "補血推薦", 料理: "炸魚排", 食材: ["1", "小孔雀魚", "1", "樹枝", "1", "採摘的紅菇", "莓果", "樹枝", "蝴蝶翅膀", "必忘我"],
          說明: "【補血40】任意魚+一個樹枝，魚開始量產的時候生的魚丟進去加樹枝，隨便塞都有很好做"},
        {類型: "補血推薦", 料理: "什錦乾果", 食材: ["1", "樺栗果", "2", "莓果", "多汁莓果", "1", "樹枝", "蝴蝶翅膀", "必忘我"],
          說明: "【補血30】一個堅果加兩個漿果，最後可以放樹枝，開始刷蝴蝶很多也可以改用蝴蝶"},
        {類型: "補血推薦", 料理: "蘇格蘭高鳥蛋", 食材: ["1", "高腳鳥蛋", "1", "紅蘿蔔", "玉米", "2", "樹枝", "蝴蝶翅膀", "必忘我"],
          說明: "【補血60】注意這個一定要生的高腳鳥蛋，紅蘿蔔或者玉米都行，後面填充物在這三種之中隨意"},
        {類型: "補血推薦", 料理: "蘇格蘭高鳥蛋", 食材: ["1", "高腳鳥蛋", "2", "採摘的紅菇", "1", "樹枝", "蝴蝶翅膀", "必忘我"],
          說明: "【補血60】如果有大量蘑菇可以改用這個配方，三種顏色蘑菇都可以"},
        {類型: "補血推薦", 料理: "海鮮牛排", 食材: ["1", "怪獸肉", "3", "小魚塊"],
          說明: "【補血60】怪物肉加上任意三個魚"},
        {類型: "補血推薦", 料理: "蛙腿三明治", 食材: ["1", "蛙腿", "1", "採摘的紅菇", "2", "採摘的紅菇", "蝴蝶翅膀", "必忘我", "NO", "樹枝"],
          說明: "【補血20】填充物禁止樹枝，避免混著變成烤肉串，蘑菇顏色沒差"},

        {類型: "理智推薦", 料理: "冰淇淋", 食材: ["1", "蜂蜜", "蜜脾", "1", "奶油", "1", "冰", "1", "莓果", "蝴蝶翅膀", "必忘我", "NO", "樹枝", "採摘的紅菇", "紅蘿蔔"],
          說明: "【理智50】大補理智，填充物禁止樹枝，以及任何蔬菜都不行"},
        {類型: "理智推薦", 料理: "果凍沙拉", 食材: ["2", "蜂蜜", "蜜脾", "2", "葉肉"],
          說明: "【理智50】大補理智"},
        {類型: "理智推薦", 料理: "海鮮牛排", 食材: ["1", "怪獸肉", "3", "小魚塊"],
          說明: "【理智33】中補理智，因為女武神不吃素，只有這個能方便回理智，怪物肉加上任意三個魚就能做"},
        {類型: "理智推薦", 料理: "生鮮薩爾薩醬", 食材: ["1", "番茄", "1", "洋蔥", "2", "採摘的紅菇", "莓果", "必忘我", "蝴蝶翅膀", "NO", "樹枝", "鳥蛋", "小肉"],
          說明: "【理智33】中補理智，有田就能量產，最後填充物任意蔬菜水果都可，禁止任何肉魚蛋"},
        {類型: "理智推薦", 料理: "奶油馬鈴薯泥", 食材: ["2", "馬鈴薯", "1", "大蒜", "1", "葉肉", "採摘的紅菇", "莓果", "必忘我", "蝴蝶翅膀", "鳥蛋", "NO", "樹枝"],
          說明: "【理智33】中補理智，有田就能量產，最後填充物任意蔬菜水果都可，禁止任何肉或魚"},
        {類型: "理智推薦", 料理: "蔬菜雞尾酒", 食材: ["1", "蘆筍", "番茄", "1", "紅蘿蔔", "玉米", "1", "冰", "1", "採摘的紅菇"],
          說明: "【理智33】中補理智，有田就能量產"},
        {類型: "理智推薦", 料理: "舒緩茶", 食材: ["1", "必忘我", "1", "冰", "1", "蜂蜜", "蜜脾", "1", "莓果", "蝴蝶翅膀", "樺栗果"],
          說明: "【理智持續回復】持續回復理智的，打王好用，如果最後填充物找不到，前面三種任意重複也可，例如放兩個必忘我"},
      ];
      function 開始推薦做法() {
        推薦做法.innerHTML = "";
        推薦做法表.forEach(做法 => {
          new_el_to_el(推薦做法, "div.做法." + 做法.類型, [
            顯示一個做法圖示列(做法),
            new_el("div.說明", 做法.說明),
          ]);
        });
        function 顯示一個做法圖示列(做法) {
          let 料理格 = 生成格("料理");
          料理格.name = 做法.料理;
          let 料理顯示 = new_el("div.格與名稱", [ 料理格, new_el("div.名稱", 做法.料理) ]);
          let 顯示食材列 = 做法.食材.map(食材名稱 => {
            if(/NO|\+|\d/.test(食材名稱)) return new_el("span", 食材名稱);
            else return 生成可選食材(食材名稱);
          });
          return new_el("div.做法圖示", [
            料理顯示,
            new_el("span", "="),
            ...顯示食材列,
          ]);
        }
      }
      function 依照分類切換推薦顯示(類型名稱) {
        食材.classList.add("hidden");
        推薦做法.classList.remove("hidden");
        find_all(推薦做法, ".做法").forEach(el => el.classList.add("hidden"));
        find_all(推薦做法, ".做法." + 類型名稱).forEach(el => el.classList.remove("hidden"));
      }
      function 依照分類切換食材顯示(類型名稱) {
        食材.classList.remove("hidden");
        推薦做法.classList.add("hidden");
        find_all(食材, "h3, .分類").forEach(el => el.classList.toggle("hidden", 類型名稱 != "全部"));
        find_all(食材, "." + 類型名稱).forEach(el => el.classList.remove("hidden"));
      }
      function 顯示食材() {
        食材.innerHTML = "";
        顯示食材分類();
        new_el_to_el(食材, "h3.肉", "肉 0.25"); 生成("肉", 0.25);
        new_el_to_el(食材, "h3.肉", "肉 0.5"); 生成("肉", 0.5);
        new_el_to_el(食材, "h3.肉", "肉 1"); 生成("肉", 1);
        new_el_to_el(食材, "h3.魚", "魚 0.25"); 生成("魚", 0.25);
        new_el_to_el(食材, "h3.魚", "魚 0.5"); 生成("魚", 0.5);
        new_el_to_el(食材, "h3.魚", "魚 1"); 生成("魚", 1);
        new_el_to_el(食材, "h3.水果", "水果 0.5"); 生成("水果", 0.5);
        new_el_to_el(食材, "h3.水果", "水果 1"); 生成("水果", 1);
        new_el_to_el(食材, "h3.蔬菜", "蔬菜 0.5"); 生成("蔬菜", 0.5);
        new_el_to_el(食材, "h3.蔬菜", "蔬菜 1"); 生成("蔬菜", 1);
        new_el_to_el(食材, "h3.配料", "蛋"); 生成("蛋");
        new_el_to_el(食材, "h3.配料", "糖精"); 生成("糖精");
        new_el_to_el(食材, "h3.配料", "乳製品"); 生成("乳製品");
        new_el_to_el(食材, "h3.配料", "冰"); 生成("冰");
        new_el_to_el(食材, "h3.配料", "種子"); 生成("種子");
        new_el_to_el(食材, "h3.其他", "怪物"); 生成("怪物");
        new_el_to_el(食材, "h3.其他", "裝飾"); 生成("裝飾");
        new_el_to_el(食材, "h3.其他", "不可食用"); 生成("不可食用");
        new_el_to_el(食材, "h3.其他", "魔法"); 生成("魔法");
        function 生成(key, value) {
          let 分類 = new_el_to_el(食材, "div.分類");
          if(["蛋", "糖精", "乳製品", "冰", "種子"].includes(key)) 分類.classList.add("配料");
          else if(["怪物", "裝飾", "不可食用", "魔法"].includes(key)) 分類.classList.add("其他");
          else 分類.classList.add(key);
          Object.entries(食材資料).filter(([name, vals]) => {
            if(value) return vals[key] == value;
            else return !!vals[key];
          })
          .forEach(([name, vals]) => {
            let 可選食材 = 生成可選食材(name);
            分類.append(可選食材);
          });
        }
      }
      function 生成可選食材(name) {
        let 格 = 生成格();
        格.name = name;
        格.addEventListener("click", () => 放上食材(name));
        return new_el("div.格與名稱", [ 格, new_el("div.名稱", name) ]);
      }
      function 放上食材(name) {
        let 空格 = 鍋子格.find(格 => !格.name);
        if(!空格) return;
        空格.name = name;
        更新結果();
      }
      const 空係數 = Object.values(食材資料).reduce((p, 資料) => {
        Object.keys(資料).forEach(key => p[key] = 0);
        return p;
      }, {});
      function 處理食譜() {
        Object.entries(食譜資料).forEach(([name, obj]) => {
          obj.name = name;
          Object.keys(空係數).forEach(key => {
            obj.係數要求 = obj.係數要求.replace(new RegExp(`^${key}|(?: )${key}|(?:\\()${key}`, "g"), "係數." + key);
          });
        });
      }
      function 更新結果() {
        let 使用食材 = 鍋子格.map(格 => 格.name).filter(v => v);
        if(使用食材.length < 4) { 結果.innerHTML = "未填滿烹飪鍋"; return; }
        結果.innerHTML = "";
        let 係數 = {...空係數};
        使用食材.forEach(name => {
          Object.entries(食材資料[name]).forEach(([p, v]) => 係數[p] += v);
        });
        let 符合 = Object.values(食譜資料).filter(資料 => !資料.係數要求 || eval(資料.係數要求));
        if(!是沃利.checked) 符合 = 符合.filter(資料 => !資料.沃專屬);
        let 最大優先權 = Math.max( ...符合.map(({優先權})=> 優先權) );
        符合 = 符合.filter(({優先權}) => 優先權 == 最大優先權);
        符合.forEach(資料 => 結果.append(生成食譜顯示(資料)));
      }
      function 生成食譜顯示(資料) {
        let 格 = 生成格("料理");
        格.name = 資料.name;
        return new_el("div.食譜顯示", [
          new_el("span", 資料.name),
          格,
          new_el("span", "HP " + 資料.HP),
          new_el("span", "FL " + 資料.FL),
          new_el("span", "SAN " + 資料.SAN),
          new_el("span", "期限 " + 資料.期限),
          new_el("span", "製作 " + 資料.時間),
          new_el("span", 資料.係數要求.replace(/係數\./g, "").replace(/\=\=/g, "=").replace(/ \&\&/g, " , ").replace(/\|/g, "或")),
        ]);
      }
      function 顯示全食譜() {
        食譜列.innerHTML = "";
        let key = 食譜排列.value;
        let 資料列 = Object.values(食譜資料);
        if(!是沃利.checked) 資料列 = 資料列.filter(資料 => !資料.沃專屬);
        資料列.sort((資料A, 資料B) => 資料B[key] - 資料A[key])
        .forEach(資料 => {
          食譜列.append(生成食譜顯示(資料));
        });
      }
    </script>
  </body>
</html>